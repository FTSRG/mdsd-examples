package hu.bme.mit.mdsd.m2m2c.queries

import "http://mit.bme.hu/mdsd/erdiagram" as erdiagram
import "hu.bme.mit.mdsd.trace"
import "hu.bme.mit.mdsd.rdb" as rdb

import java hu.bme.mit.mdsd.m2m2c.util.CommonHelperMethods


/////////////////////////////////////// Traceability //////////////////////////////////////////
// Linked elements: 
// 	Entity <> Table
// 	Attribute <> Column
// 	Relation <> Table
// 	RelationEnding <> ForeignKey
// No traceability links: 
//  (entity without key attribute) <> default Key
// 	(is-a) <> ForeignKey


/////////////////////////////////////// NamedElement //////////////////////////////////////////
pattern nameToPropagate(sourceElement: erdiagram::NamedElement, targetElement: rdb::NamedElement) {
	find traceOfElement(_, _, sourceElement, targetElement);
	erdiagram::NamedElement.name(sourceElement, _); // name is not unset, there is a name to propagate
	neg find nameMapped(sourceElement, targetElement);
}
private pattern nameMapped(sourceElement: erdiagram::NamedElement, targetElement: rdb::NamedElement) {
	find traceOfElement(_, _, sourceElement, targetElement);
	erdiagram::NamedElement.name(sourceElement, name);
	rdb::NamedElement.name(targetElement, name);
}


/////////////////////////////////////// Entity //////////////////////////////////////////

pattern entityCreated(entity: Entity){
	neg find traceOfElement(_, _, entity, _);
}
// no delete pattern - see tableToRemove


///////////////////////// Default primary key (if entity has no key) //////////////////////////////////////////


pattern defaultPrimaryKeyRequired(entity: Entity, table: Table){
	find traceOfElement(_, _, entity, table);
	Entity.name(entity, _); // name is not unset, there is a name to propagate
	
	// no key attribute exists		
	neg Entity.attributes.isKey(entity, true); // TODO what if inherited?
	
	neg find defaultPrimaryKeyMapped(entity, table, _);
}
private pattern defaultPrimaryKeyMapped(entity: Entity, table: Table, key: Key) {
	find traceOfElement(_, _, entity, table);
	Table.columns(table, key);
	
	// no key attribute exists		
	neg Entity.attributes.isKey(entity, true); // TODO what if inherited?
	
	// if names do not match, do not consider this a valid mapping
	Entity.name(entity, eName);
	Key.name(key, kName);
	kName == eval(CommonHelperMethods.toKeyColumnName(eName));
}
pattern defaultPrimaryKeyToRemove(table: Table, key: Key){
	Table.columns(table, key);
	neg find defaultPrimaryKeyMapped(_, table, key);
	
	// if this key column is not a default primary key, but corresponds to an attribute instead
	// do not delete it for name mismatch;
	// default key column is recognized by not having a trace link to an attribute
	neg find traceOfElement(_, _, _, key);
	
}


/////////////////////////////////////// Attribute //////////////////////////////////////////

pattern attributeCreated(
	attribute: Attribute, contextEntity: Entity, contextTable: Table
){
	Entity.attributes(contextEntity, attribute);
	find traceOfElement(_, _, contextEntity, contextTable);
	neg find traceOfElement(_, _, attribute, _);
}
private pattern attributeMapped(
	attribute: Attribute, column: Column,
	contextEntity: Entity, contextTable: Table
){
	Entity.attributes(contextEntity, attribute);
	find traceOfElement(_, _, contextEntity, contextTable);
	find traceOfElement(_, _, attribute, column);
	
	// the column shall be a key exactly if the attribute was...
	// otherwise the mapping is invalid, and the column must be deleted&recreated with the right type
	Attribute.isKey(attribute, attributeIsKey);
	count Key(column) == eval(if (attributeIsKey) 1 else 0);
}
pattern attributeDeleted(
	column: Column, contextTable: Table, trace: Trace
){
	Table.columns(contextTable, column);
	neg find attributeMapped(_, column, _, contextTable);
	// if this column does not correspond to an attribute, 
	// do not delete it for lack of an attribute
	Trace.rdbElement(_, column); // default table primary key columns, created for entity, have no trace link
	neg ForeignKey(column); // columns created for association or is-a are foreign key columns

	Trace.rdbElement(trace, column); // find trace element and remove alongside
}

pattern typeToPropagate(attribute: Attribute, column: Column) {
	find traceOfElement(_, _, attribute, column);
	Attribute.type(attribute, _); // type is not unset, there is a type to propagate
	neg find typeMapped(attribute, column);
}
private pattern typeMapped(attribute: Attribute, column: Column) {
	find traceOfElement(_, _, attribute, column);
	Attribute.type(attribute, aType);
	Column.type(column, cType);
	cType == eval(CommonHelperMethods::toColumnType(aType));
}


/////////////////////////////////////// Is-A //////////////////////////////////////////
pattern isaCreated(
	subE: Entity, superE: Entity, subT: Table, superT: Table, superKey: Key
){
	Entity.isA(subE, superE);
	find traceOfElement(_, _, subE, subT);
	find traceOfElement(_, _, superE, superT);
	Table.columns(superT, superKey);
	
	neg find isaMapped(subE, superE, subT, superT, superKey, _);
}
pattern isaMapped(
	subE: Entity, superE: Entity, subT: Table, superT: Table, superKey: Key, foreignKey: ForeignKey
){
	Entity.isA(subE, superE);
	find traceOfElement(_, _, subE, subT);
	find traceOfElement(_, _, superE, superT);
	Table.columns(superT, superKey);
	Table.columns(subT, foreignKey);
	ForeignKey.referencedKey(foreignKey, superKey);
	
	// if names do not match, delete&re-create foreign key
	Key.name(superKey, name);
	ForeignKey.name(foreignKey, name);
	
	// if types do not match, delete&re-create foreign key
	Key.type(superKey, type);
	ForeignKey.type(foreignKey, type);
}
pattern isaDeleted(
	subT: Table, foreignKey: ForeignKey
){
	Table.columns(subT, foreignKey);
	neg find isaMapped(_, _, subT, _, _, foreignKey);
	// if the foreign key has no trace link, 
	// it corresponds to an is-a rather than a relation end than an is-a 
	neg find traceOfElement(_, _, _, foreignKey);
}


/////////////////////////////////////// Relation //////////////////////////////////////////

pattern relationCreated(relation: Relation){
	neg find traceOfElement(_, _, relation, _);
}
// no delete pattern - see tableToRemove

pattern relationEndCreated(
	ending: RelationEnding, refKey: Key,
	contextRelation: Relation, contextTable: Table
){
	find hasEnding(contextRelation, ending);
	find traceOfElement(_, _, contextRelation, contextTable);
	RelationEnding.target(ending, refEntity);
	find traceOfElement(_, _, refEntity, refTable);
	Table.columns(refTable, refKey);
	Key(refKey); // redundant, already type restricted in the parameters
	
	neg find relationEndMapped(
		ending, _, refKey, contextRelation, contextTable
	);
}
private pattern hasEnding(
	contextRelation: Relation, ending: RelationEnding
) {
	Relation.leftEnding(contextRelation, ending);
} or  {
	Relation.rightEnding(contextRelation, ending);
}
private pattern relationEndMapped(
	ending: RelationEnding, foreignKey: ForeignKey, 
	refKey: Key,
	contextRelation: Relation, contextTable: Table	
){
	find hasEnding(contextRelation, ending);
	Table.columns(contextTable, foreignKey);
	find traceOfElement(_, _, contextRelation, contextTable);
	find traceOfElement(_, _, ending, foreignKey);
	
	RelationEnding.target(ending, refEntity);
	find traceOfElement(_, _, refEntity, refTable);
	Table.columns(refTable, refKey);
	ForeignKey.referencedKey(foreignKey, refKey);
	
	// if types do not match, delete&re-create foreign key
	Key.type(refKey, type);
	ForeignKey.type(foreignKey, type);
}
pattern relationEndDeleted(
	foreignKey: ForeignKey, contextTable: Table, trace: Trace
){
	Table.columns(contextTable, foreignKey);
	neg find relationEndMapped(
		_, foreignKey, _, _, contextTable
	);
	// if the foreign key has a trace link, 
	// it corresponds to a relation end rather than an is-a 
	Trace.rdbElement(trace, foreignKey); // find trace element and remove alongside
}

/////////////////////////////////////// Table //////////////////////////////////////////

// Works for entity and relation tables as well
pattern tableToRemove(table: Table, trace: Trace){
	neg find traceOfElement(_, _, _, table);
	Trace.rdbElement(trace, table); // find trace element and remove alongside
}

